# ===========================================================================
# Logstash Pipeline: Security Logs from Remote Linux Clients
# ===========================================================================
# Purpose: Process security logs (syslog, auth.log, fail2ban, intrusion detection)
# Input: Filebeat from remote Ubuntu clients
# Output: Elasticsearch with security index pattern
# ===========================================================================

input {
    beats {
        port => 5044
        # Accept connections from remote clients
        host => "0.0.0.0"
        # Optional: SSL/TLS for Filebeat connections (recommended for production)
        # ssl => true
        # ssl_certificate => "/certs/logstash.crt"
        # ssl_key => "/certs/logstash.key"
        # ssl_certificate_authorities => ["/certs/ca.crt"]
    }
}

filter {
    # Tag logs by source type
    if [log][file][path] =~ "/var/log/auth.log" {
        mutate {
            add_tag => ["auth", "security"]
        }
    }

    if [log][file][path] =~ "/var/log/syslog" {
        mutate {
            add_tag => ["syslog", "system"]
        }
    }

    if [log][file][path] =~ "/var/log/fail2ban" {
        mutate {
            add_tag => ["fail2ban", "security", "intrusion"]
        }
    }

    # Parse syslog format
    if "syslog" in [tags] or "auth" in [tags] {
        grok {
            match => {
                "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}"
            }
            add_field => [ "received_at", "%{@timestamp}" ]
        }

        # Parse timestamp
        date {
            match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
            target => "@timestamp"
        }
    }

    # Detect SSH authentication attempts
    if "auth" in [tags] {
        # Failed password
        if [message] =~ /Failed password/ {
            grok {
                match => {
                    "message" => "Failed password for (?:invalid user )?%{USER:ssh_user} from %{IP:ssh_source_ip} port %{INT:ssh_port}"
                }
                add_tag => ["ssh_failed_auth", "threat"]
            }
        }

        # Successful authentication
        if [message] =~ /Accepted password|Accepted publickey/ {
            grok {
                match => {
                    "message" => "Accepted (?:password|publickey) for %{USER:ssh_user} from %{IP:ssh_source_ip} port %{INT:ssh_port}"
                }
                add_tag => ["ssh_successful_auth"]
            }
        }

        # Invalid user attempts
        if [message] =~ /Invalid user/ {
            grok {
                match => {
                    "message" => "Invalid user %{USER:ssh_invalid_user} from %{IP:ssh_source_ip}"
                }
                add_tag => ["ssh_invalid_user", "threat"]
            }
        }
    }

    # Parse fail2ban logs
    if "fail2ban" in [tags] {
        grok {
            match => {
                "message" => "%{TIMESTAMP_ISO8601:fail2ban_timestamp} %{WORD:fail2ban_loglevel}%{SPACE}%{NOTSPACE:fail2ban_section}: %{WORD:fail2ban_action} %{IP:banned_ip}"
            }
            add_tag => ["fail2ban_action"]
        }
    }

    # Add geolocation for source IPs
    if [ssh_source_ip] {
        geoip {
            source => "ssh_source_ip"
            target => "geoip"
        }
    }

    if [banned_ip] {
        geoip {
            source => "banned_ip"
            target => "geoip"
        }
    }

    # Security severity classification
    if "threat" in [tags] {
        mutate {
            add_field => { "security_severity" => "high" }
        }
    } else if "ssh_successful_auth" in [tags] {
        mutate {
            add_field => { "security_severity" => "info" }
        }
    } else if "fail2ban_action" in [tags] {
        mutate {
            add_field => { "security_severity" => "medium" }
        }
    }

    # Remove unnecessary fields
    mutate {
        remove_field => ["agent", "ecs", "input", "host"]
    }
}

output {
    # Send to Elasticsearch with security index pattern
    elasticsearch {
        hosts => "${ELASTICSEARCH_HOST_PORT}"
        user => "${ELASTIC_USERNAME}"
        password => "${ELASTIC_PASSWORD}"

        # Logstash 9: SSL configuration
        ssl_enabled => true
        ssl_verification_mode => "full"
        ssl_certificate_authorities => "/certs/ca.crt"

        # Dynamic index based on date
        index => "security-logs-%{+YYYY.MM.dd}"

        # ILM and template management
        manage_template => true
        template_name => "security-logs"
        ilm_enabled => auto
    }

    # Optional: Debug output (comment out in production)
    # stdout {
    #     codec => rubydebug
    # }
}
